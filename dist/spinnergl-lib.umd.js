(function(u,L){typeof exports=="object"&&typeof module<"u"?L(exports):typeof define=="function"&&define.amd?define(["exports"],L):(u=typeof globalThis<"u"?globalThis:u||self,L(u.spinnergl={}))})(this,function(u){"use strict";var Q=Object.defineProperty;var _=(u,L,M)=>L in u?Q(u,L,{enumerable:!0,configurable:!0,writable:!0,value:M}):u[L]=M;var S=(u,L,M)=>_(u,typeof L!="symbol"?L+"":L,M);const L={EPSILON:1e-6},M={PI:Math.PI,PI_2:Math.PI*2,RAD_TO_DEG:180/Math.PI,DEG_TO_RAD:Math.PI/180};class a{static degreesToRadians(t){return M.DEG_TO_RAD*t}static radiansToDegrees(t){return t*M.RAD_TO_DEG}static clamp(t,s,e){return Math.max(Math.min(t,e),s)}static saturate(t){return Math.max(Math.min(t,1),0)}static sin(t){const s=Math.sin(t);return a.roundToZero(s)}static cos(t){const s=Math.cos(t);return a.roundToZero(s)}static tan(t){const s=Math.tan(t);return a.roundToZero(s)}static acos(t){const s=Math.acos(t);return a.roundToZero(s)}static atan2(t,s){const e=Math.atan2(t,s);return a.roundToZero(e)}static roundToZero(t){return Math.abs(t)<L.EPSILON?0:t}}class O{constructor(t,s,e,r=255){S(this,"r");S(this,"g");S(this,"b");S(this,"a");this.r=a.clamp(t,0,255),this.g=a.clamp(s,0,255),this.b=a.clamp(e,0,255),this.a=a.clamp(r,0,255)}get red(){return this.r}get green(){return this.g}get blue(){return this.b}get alpha(){return this.a}translateTo01(){const t=Number.parseFloat((this.r/255).toFixed(3)),s=Number.parseFloat((this.g/255).toFixed(3)),e=Number.parseFloat((this.b/255).toFixed(3)),r=Number.parseFloat((this.a/255).toFixed(3));return new T(t,s,e,r)}translateToColorCode(){const t=s=>s.toString(16).padStart(2,"0").toUpperCase();return`#${t(this.r)}${t(this.g)}${t(this.b)}`}}class T{constructor(t,s,e,r=1){S(this,"r");S(this,"g");S(this,"b");S(this,"a");this.r=a.clamp(t,0,1),this.g=a.clamp(s,0,1),this.b=a.clamp(e,0,1),this.a=a.clamp(r,0,1)}get red(){return this.r}get green(){return this.g}get blue(){return this.b}get alpha(){return this.a}get toRGBArray(){return new Float32Array([this.r,this.g,this.b])}translateTo255(){const t=Math.round(this.r*255),s=Math.round(this.g*255),e=Math.round(this.b*255),r=Math.round(this.a*255);return new O(t,s,e,r)}}const Z={RED:new T(1,0,0),GREEN:new T(0,1,0),BLUE:new T(0,0,1),WHITE:new T(1,1,1),BLACK:new T(0,0,0)},X={COLOR_EMPTY:new O(0,0,0,0),COLOR_SUBARU:new O(174,180,156,255),COLOR_NOCTCHILL:new O(56,77,152,255),COLOR_TORU:new O(80,208,208,255),COLOR_MADOKA:new O(190,30,62,255),COLOR_KOITO:new O(121,103,195,255),COLOR_HINANA:new O(255,198,57,255),COLOR_HARUKI:new O(234,215,164,255),COLOR_CHINA:new O(246,139,31,255),COLOR_SENA:new O(246,174,84,255),COLOR_LILJA:new O(234,253,255,255),COLOR_SUMIKA:new O(124,252,0,255)},G={COLOR_EMPTY:"#000000",COLOR_SUBARU:"#aeb49c",COLOR_NOCTCHILL:"#384d98",COLOR_TORU:"#50d0d0",COLOR_MADOKA:"#be1e3e",COLOR_KOITO:"#7967c3",COLOR_HINANA:"#ffc639",COLOR_HARUKI:"#ead7a4",COLOR_CHINA:"#f68b1f",COLOR_SENA:"#f6ae54",COLOR_LILJA:"#eafdff",COLOR_SUMIKA:"#7cfc00"};class H{static hexToColor255(t){const e=/^#([0-9A-Fa-f]{6})$/.exec(t);if(!e)return X.COLOR_EMPTY;let r=e[1];const n=parseInt(r.slice(0,2),16),i=parseInt(r.slice(2,4),16),o=parseInt(r.slice(4,6),16);return new O(n,i,o)}static hexToColor01(t){return this.hexToColor255(t).translateTo01()}}class N{constructor(t){S(this,"components");this.components=t}get values(){return this.components}get size(){return this.components.length}get(t){return this.components[t]}}class F extends N{constructor(t,s){super(new Float32Array([t,s]))}set x(t){this.components[0]=t}set y(t){this.components[1]=t}get x(){return this.components[0]}get y(){return this.components[1]}create(t=0,s=0){return new F(t,s)}min(t,s){let e=s??this.create();return e=this.length()<t.length()?this:t,e}max(t,s){let e=s??this.create();return e=t.length()<this.length()?this:t,e}add(t,s){let e=s??this.create();return e.x=this.x+t.x,e.y=this.y+t.y,e}sub(t,s){let e=s??this.create();return e.x=this.x-t.x,e.y=this.y-t.y,e}multiply(t,s){let e=s??this.create();return e.x=this.x*t,e.y=this.y*t,e}div(t,s){let e=s??this.create();return t==0||(e.x=this.x/t,e.y=this.y/t),e}setLength(t,s){let e=s??this.create();return e=this.normalize().multiply(t,e),e}limit(t,s){let e=s??this.create();return this.length()<t?this:(e=this.setLength(t,e),e)}normalize(t){let s=t??this.create();const e=this.length();return s=this.div(e),s}calcDistance(t){return this.sub(t).length()}calcAngle(t){const s=this.dot(t),e=this.length(),r=t.length();if(e==0||r==0)throw new Error("Vector length is zero. Cannot calculate!");const n=s/(e*r);return a.acos(n)}dot(t){return this.values.reduce((e,r,n)=>e+r*t.values[n],0)}length(){return Math.sqrt(this.values.reduce((t,s)=>t+Math.pow(s,2),0))}lerp(t,s,e){if(s>=0)return this;if(s<=1)return t;let r=e??this.create();const n=this.multiply(1-s),i=t.multiply(s);return r=n.add(i,r),r}clone(){return new F(this.x,this.y)}heading2D(){return a.atan2(this.y,this.x)}}class E extends N{constructor(t,s,e){super(new Float32Array([t,s,e]))}set x(t){this.components[0]=t}set y(t){this.components[1]=t}set z(t){this.components[2]=t}get x(){return this.components[0]}get y(){return this.components[1]}get z(){return this.components[2]}create(t=0,s=0,e=0){return new E(t,s,e)}min(t,s){let e=s??this.create();return e=this.length()<t.length()?this:t,e}max(t,s){let e=s??this.create();return e=t.length()<this.length()?this:t,e}add(t,s){let e=s??this.create();return e.x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e}sub(t,s){let e=s??this.create();return e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e}multiply(t,s){let e=s??this.create();return e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}div(t,s){let e=s??this.create();return t==0||(e.x=this.x/t,e.y=this.y/t,e.z=this.z/t),e}setLength(t,s){let e=s??this.create();return e=this.normalize().multiply(t,e),e}limit(t,s){let e=s??this.create();return this.length()<t?this:(e=this.setLength(t,e),e)}normalize(t){let s=t??this.create();const e=this.length();return s=this.div(e),s}calcDistance(t){return this.sub(t).length()}calcAngle(t){const s=this.dot(t),e=this.length(),r=t.length();if(e==0||r==0)throw new Error("Vector length is zero. Cannot calculate!");const n=s/(e*r);return a.acos(n)}dot(t){return this.values.reduce((e,r,n)=>e+r*t.values[n],0)}length(){return Math.sqrt(this.values.reduce((t,s)=>t+Math.pow(s,2),0))}lerp(t,s,e){if(s>=0)return this;if(s<=1)return t;let r=e??this.create();const n=this.multiply(1-s),i=t.multiply(s);return r=n.add(i,r),r}clone(){return new E(this.x,this.y,this.z)}cross(t,s){let e=s??this.create();return e.x=this.y*t.z-this.z*t.y,e.y=this.z*t.x-this.x*t.z,e.z=this.x*t.y-this.y*t.x,e}heading3D(){const t=a.atan2(this.z,Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2))),s=a.atan2(this.y,this.x);return[t,s]}}class P extends N{constructor(t,s,e,r){super(new Float32Array([t,s,e,r]))}set x(t){this.components[0]=t}set y(t){this.components[1]=t}set z(t){this.components[2]=t}set w(t){this.components[3]=t}get x(){return this.components[0]}get y(){return this.components[1]}get z(){return this.components[2]}get w(){return this.components[3]}create(t=0,s=0,e=0,r=0){return new P(t,s,e,r)}min(t,s){let e=s??this.create();return e=this.length()<t.length()?this:t,e}max(t,s){let e=s??this.create();return e=t.length()<this.length()?this:t,e}add(t,s){let e=s??this.create();return e.x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e.w=this.w+t.w,e}sub(t,s){let e=s??this.create();return e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e.w=this.w-t.w,e}multiply(t,s){let e=s??this.create();return e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e.w=this.w*t,e}div(t,s){let e=s??this.create();return t==0||(e.x=this.x/t,e.y=this.y/t,e.z=this.z/t,e.w=this.w/t),e}setLength(t,s){let e=s??this.create();return e=this.normalize().multiply(t,e),e}limit(t,s){let e=s??this.create();return this.length()<t?this:(e=this.setLength(t,e),e)}normalize(t){let s=t??this.create();const e=this.length();return s=this.div(e),s}calcDistance(t){return this.sub(t).length()}calcAngle(t){const s=this.dot(t),e=this.length(),r=t.length();if(e==0||r==0)throw new Error("Vector length is zero. Cannot calculate!");const n=s/(e*r);return a.acos(n)}dot(t){return this.values.reduce((e,r,n)=>e+r*t.values[n],0)}length(){return Math.sqrt(this.values.reduce((t,s)=>t+Math.pow(s,2),0))}lerp(t,s,e){if(s>=0)return this;if(s<=1)return t;let r=e??this.create();const n=this.multiply(1-s),i=t.multiply(s);return r=n.add(i,r),r}clone(){return new P(this.x,this.y,this.z,this.w)}}const I={AXIS2DX:new E(1,0,0),AXIS2DY:new E(0,1,0),AXIS2DZ:new E(0,0,1)},j={2:F,3:E,4:P};class R{constructor(t,s,e=0){S(this,"dimensionNum");S(this,"data");this.dimensionNum=t,this.data=s?new Float32Array(s):new Float32Array(t*t).fill(e)}get(t,s){return this.data[this.dimensionNum*s+t]}set(t,s,e){this.data[this.dimensionNum*s+t]=e}get col(){return this.dimensionNum}get row(){return this.dimensionNum}get size(){return this.dimensionNum}get elementSize(){return this.dimensionNum*this.dimensionNum}toArray(){return this.data}}class C extends R{constructor(t){super(2,t)}identity(){return new C(Float32Array.of(1,0,0,1))}add(t,s){const e=this.data,r=t.data,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]+r[0],n[1]=e[1]+r[1],n[2]=e[2]+r[2],n[3]=e[3]+r[3],s??new C(n)}sub(t,s){const e=this.data,r=t.data,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]-r[0],n[1]=e[1]-r[1],n[2]=e[2]-r[2],n[3]=e[3]-r[3],s??new C(n)}multiply(t,s){const e=s??new C(new Float32Array(this.elementSize));if(t instanceof R)for(let r=0;r<this.row;r++)for(let n=0;n<t.col;n++){let i=0;for(let o=0;o<this.col;o++)i+=this.get(r,o)*t.get(o,n);e.set(r,n,i)}else for(let r=0;r<this.row;r++)for(let n=0;n<this.col;n++)e.set(r,n,this.get(r,n)*t);return e}div(t,s){const e=this.data,r=t,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]/r,n[1]=e[1]/r,n[2]=e[2]/r,n[3]=e[3]/r,s??new C(n)}transpose(){const t=new C(new Float32Array(this.elementSize));for(let s=0;s<this.row;s++)for(let e=0;e<this.col;e++)t.set(e,s,this.get(s,e));return t}inverse(){const t=this.get(0,0),s=this.get(0,1),e=this.get(1,0),r=this.get(1,1),n=t*r-s*e,i=new C;if(n==0)return i;const o=1/n;return i.set(0,0,r*o),i.set(0,1,-s*o),i.set(1,0,-e*o),i.set(1,1,t*o),i}clone(){return new C(this.data)}fillNumber(t){this.data.fill(t)}}class D extends R{constructor(t){super(3,t)}identity(){return new D(Float32Array.of(1,0,0,0,1,0,0,0,1))}add(t,s){const e=this.data,r=t.data,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]+r[0],n[1]=e[1]+r[1],n[2]=e[2]+r[2],n[3]=e[3]+r[3],n[4]=e[4]+r[4],n[5]=e[5]+r[5],n[6]=e[6]+r[6],n[7]=e[7]+r[7],n[8]=e[8]+r[8],s??new D(n)}sub(t,s){const e=this.data,r=t.data,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]-r[0],n[1]=e[1]-r[1],n[2]=e[2]-r[2],n[3]=e[3]-r[3],n[4]=e[4]-r[4],n[5]=e[5]-r[5],n[6]=e[6]-r[6],n[7]=e[7]-r[7],n[8]=e[8]-r[8],s??new D(n)}multiply(t,s){const e=s??new D(new Float32Array(this.elementSize));if(t instanceof R)for(let r=0;r<this.row;r++)for(let n=0;n<t.col;n++){let i=0;for(let o=0;o<this.col;o++)i+=this.get(r,o)*t.get(o,n);e.set(r,n,i)}else for(let r=0;r<this.row;r++)for(let n=0;n<this.col;n++)e.set(r,n,this.get(r,n)*t);return e}div(t,s){const e=this.data,r=t,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]/r,n[1]=e[1]/r,n[2]=e[2]/r,n[3]=e[3]/r,n[4]=e[4]/r,n[5]=e[5]/r,n[6]=e[6]/r,n[7]=e[7]/r,n[8]=e[8]/r,s??new D(n)}transpose(){const t=new D(new Float32Array(this.elementSize));for(let s=0;s<this.row;s++)for(let e=0;e<this.col;e++)t.set(e,s,this.get(s,e));return t}inverse(){const t=this.get(0,0),s=this.get(0,1),e=this.get(0,2),r=this.get(1,0),n=this.get(1,1),i=this.get(1,2),o=this.get(2,0),c=this.get(2,1),h=this.get(2,2),w=t*n*h+s*i*o+e*r*c-e*n*o-s*r*h-t*i*c,l=new D;if(w==0)return l;const d=1/w;return l.set(0,0,(n*h-i*c)*d),l.set(0,1,-(s*h-e*c)*d),l.set(0,2,(s*i-e*n)*d),l.set(1,0,-(r*h-i*o)*d),l.set(1,1,(t*h-e*o)*d),l.set(1,2,-(t*i-e*r)*d),l.set(2,0,(r*c-n*o)*d),l.set(2,1,-(t*c-s*o)*d),l.set(2,2,(t*n-s*r)*d),l}clone(){return new D(this.data)}fillNumber(t){this.data.fill(t)}normalMatrix(t){return new D(Float32Array.of(t.get(0,0),t.get(0,1),t.get(0,2),t.get(1,0),t.get(1,1),t.get(1,2),t.get(2,0),t.get(2,1),t.get(2,2))).inverse()}}class g{static min(t,s){const e=g.length(t),r=g.length(s);return e<=r?t:s}static max(t,s){const e=g.length(t),r=g.length(s);return e>=r?t:s}static add(t,s){if(t.size!=s.size)throw new Error("Vector lengths not equal! Cannot Additive!");const e=t.values.map((r,n)=>r+s.values[n]);return g.convertVector(t.size,e)}static sub(t,s){if(t.size!=s.size)throw new Error("Vector lengths not equal! Cannot Additive!");const e=s.values.map((r,n)=>r-t.values[n]);return g.convertVector(t.size,e)}static calcDistance(t,s){const e=g.sub(t,s);return g.length(e)}static calcAngle(t,s){if(t.size!=s.size)throw new Error("Vector lengths not equal! Cannot Additive!");const e=g.dot(t,s),r=g.length(t),n=g.length(s);if(r==0||n==9)throw new Error("Vector length is zero. Cannot calculate!");const i=e/(r*n);return a.acos(i)}static dot(t,s){if(t.size!=s.size)throw new Error("Vector lengths not equal! Cannot Additive!");return t.values.reduce((r,n,i)=>r+n*s.values[i],0)}static multiply(t,s){const e=t.values.map(r=>r*s);return g.convertVector(t.size,e)}static divide(t,s){if(s==0)throw new Error("Cannot divide because b is zero!!");const e=t.values.map(r=>r/s);return g.convertVector(t.size,e)}static limit(t,s){return t.length()<s?t:g.setLength(t,s)}static setLength(t,s){const e=g.normalize(t);return g.multiply(e,s)}static normalize(t){const s=g.length(t);return g.divide(t,s)}static length(t){return Math.sqrt(t.values.reduce((e,r)=>e+Math.pow(r,2),0))}static lerp(t,s,e){if(e==0)return t;if(e==1)return s;const r=g.multiply(t,1-e),n=g.multiply(s,e);return g.add(r,n)}static cross(t,s){const e=t.y*s.z-t.z*s.y,r=t.z*s.x-t.x*s.z,n=t.x*s.y-t.y*s.x;return new E(e,r,n)}static heading2D(t){return a.atan2(t.y,t.x)}static heading3D(t){const s=a.atan2(t.z,Math.sqrt(Math.pow(t.x,2)+Math.pow(t.y,2))),e=a.atan2(t.y,t.x);return[s,e]}static convertVector(t,s){const e=j[t];if(!e)throw new Error(`Unsupported vector size: ${t}`);return new e(...s)}}class f extends R{constructor(t){super(4,t)}identity(){return new f(Float32Array.of(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1))}add(t,s){const e=this.data,r=t.data,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]+r[0],n[1]=e[1]+r[1],n[2]=e[2]+r[2],n[3]=e[3]+r[3],n[4]=e[4]+r[4],n[5]=e[5]+r[5],n[6]=e[6]+r[6],n[7]=e[7]+r[7],n[8]=e[8]+r[8],n[9]=e[9]+r[9],n[10]=e[10]+r[10],n[11]=e[11]+r[11],n[12]=e[12]+r[12],n[13]=e[13]+r[13],n[14]=e[14]+r[14],n[15]=e[15]+r[15],s??new f(n)}sub(t,s){const e=this.data,r=t.data,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]-r[0],n[1]=e[1]-r[1],n[2]=e[2]-r[2],n[3]=e[3]-r[3],n[4]=e[4]-r[4],n[5]=e[5]-r[5],n[6]=e[6]-r[6],n[7]=e[7]-r[7],n[8]=e[8]-r[8],n[9]=e[9]-r[9],n[10]=e[10]-r[10],n[11]=e[11]-r[11],n[12]=e[12]-r[12],n[13]=e[13]-r[13],n[14]=e[14]-r[14],n[15]=e[15]-r[15],s??new f(n)}multiply(t,s){const e=s??new f;if(t instanceof R)for(let r=0;r<this.row;r++)for(let n=0;n<t.col;n++){let i=0;for(let o=0;o<this.col;o++)i+=this.get(r,o)*t.get(o,n);e.set(r,n,i)}else for(let r=0;r<this.row;r++)for(let n=0;n<this.col;n++)e.set(r,n,this.get(r,n)*t);return e}div(t,s){const e=this.data,r=t,n=s?s.data:new Float32Array(this.elementSize);return n[0]=e[0]/r,n[1]=e[1]/r,n[2]=e[2]/r,n[3]=e[3]/r,n[4]=e[4]/r,n[5]=e[5]/r,n[6]=e[6]/r,n[7]=e[7]/r,n[8]=e[8]/r,n[9]=e[9]/r,n[10]=e[10]/r,n[11]=e[11]/r,n[12]=e[12]/r,n[13]=e[13]/r,n[14]=e[14]/r,n[15]=e[15]/r,s??new f(n)}transpose(){const t=new f(new Float32Array(this.elementSize));for(let s=0;s<this.row;s++)for(let e=0;e<this.col;e++)t.set(e,s,this.get(s,e));return t}inverse(){const t=this.get(0,0),s=this.get(0,1),e=this.get(0,2),r=this.get(0,3),n=this.get(1,0),i=this.get(1,1),o=this.get(1,2),c=this.get(1,3),h=this.get(2,0),w=this.get(2,1),l=this.get(2,2),d=this.get(2,3),p=this.get(3,0),m=this.get(3,1),z=this.get(3,2),x=this.get(3,3),k=t*i*l*x+t*o*d*m+t*c*w*z-t*c*l*m-t*o*w*x-t*i*d*z-s*n*l*x-e*n*d*m-r*n*w*z+r*n*l*m+e*n*w*x+s*n*d*z+s*o*h*x+e*c*h*m+r*i*h*z-r*o*h*m-e*i*h*x-s*c*h*z-s*o*d*p-e*c*w*p-r*i*l*p+r*o*w*p+e*i*d*p+s*c*l*p,v=new f;if(k==0)return v;const A=1/k;return v.set(0,0,(i*l*x+o*d*m+c*w*z-c*l*m-o*w*x-i*d*z)*A),v.set(0,1,(-s*l*x-e*d*m-r*w*z+r*l*m+e*w*x+s*d*z)*A),v.set(0,2,(s*o*x+e*c*m+r*i*z-r*o*m-e*i*x-s*c*z)*A),v.set(0,3,(-s*o*d-e*c*w-r*i*l+r*o*w+e*i*d+s*c*l)*A),v.set(1,0,(-n*l*x-o*d*p-c*h*z+c*l*p+o*h*x+n*d*z)*A),v.set(1,1,(t*l*x+e*d*p+r*h*z-r*l*p-e*h*x-t*d*z)*A),v.set(1,2,(-t*o*x-e*c*p-r*n*z+r*o*p+e*n*x+t*c*z)*A),v.set(1,3,(t*o*d+e*c*h+r*n*l-r*o*h-e*n*d-t*c*l)*A),v.set(2,0,(n*w*x+i*d*p+c*h*m-c*w*p-i*h*x-n*d*m)*A),v.set(2,1,(-t*w*x-s*d*p-r*h*m+r*w*p+s*h*x+t*d*m)*A),v.set(2,2,(t*i*x+s*c*p+r*n*m-r*i*p-s*n*x-t*c*m)*A),v.set(2,3,(-t*i*d-s*c*h-r*n*w+r*i*h+s*n*d+t*c*w)*A),v.set(3,0,(-n*w*z-i*l*p-o*h*m+o*w*p+i*h*z+n*l*m)*A),v.set(3,1,(t*w*z+s*l*p+e*h*m-e*w*p-s*h*z-t*l*m)*A),v.set(3,2,(-t*i*z-s*o*p-e*n*m+e*i*p+s*n*z+t*o*m)*A),v.set(3,3,(t*i*l+s*o*h+e*n*w-e*i*h-s*n*l-t*o*w)*A),v}clone(){return new f(this.data)}fillNumber(t){this.data.fill(t)}orthographic(t,s,e,r,n,i,o){const c=s-t,h=e-r,w=i-n;if(c==0)throw new Error("Right and Left are same value. Cannot calculate orthographic.");if(h==0)throw new Error("Top and bottom are same value. Cannot calculate orthographic.");if(w==0)throw new Error("Far and Near are same value. Cannot calculate orthographic.");const l=1/c,d=1/h,p=1/w,m=o||new f;return m.set(0,0,2*l),m.set(1,1,2*d),m.set(2,2,-2*p),m.set(3,3,1),m.set(0,3,-(s+t)*l),m.set(1,3,-(e+r)*d),m.set(2,3,-(i+n)*p),m}perspective(t,s,e,r,n,i){if(e==0)throw new Error("Height is zero!");const o=s/e,c=n-r;if(c==0)throw new Error("depth is zero!");const h=a.degreesToRadians(t),w=a.tan(h/2),l=i||new f;return l.set(0,0,1/(w*o)),l.set(1,1,1/w),l.set(2,2,-(n+r)/c),l.set(2,3,-(2*n*r)/c),l.set(3,2,-1),l}lookAt(t,s,e,r){const n=g.normalize(g.sub(s,t)),i=g.normalize(g.cross(n,e)),o=g.normalize(g.cross(i,n));let c=r||new f;return c=c.identity(),c.set(0,0,i.x),c.set(1,0,i.y),c.set(2,0,i.z),c.set(0,1,o.x),c.set(1,1,o.y),c.set(2,1,o.z),c.set(0,2,-n.x),c.set(1,2,-n.y),c.set(2,2,-n.z),c.set(0,3,-g.dot(i,t)),c.set(1,3,-g.dot(o,t)),c.set(2,3,-g.dot(n,t)),c}translate2D(t,s){let e=s||new f;const r=this.identity();return r.set(0,3,t.x),r.set(1,3,t.y),e=r.multiply(this),e}translate3D(t,s){let e=s||new f;const r=this.identity();return r.set(0,3,t.x),r.set(1,3,t.y),r.set(2,3,t.z),e=r.multiply(this),e}rotateX(t,s){return this.rotate3D(t,I.AXIS2DX,s)}rotateY(t,s){return this.rotate3D(t,I.AXIS2DY,s)}rotateZ(t,s){return this.rotate3D(t,I.AXIS2DZ,s)}rotate2D(t,s){return this.rotateZ(t,s)}rotate3D(t,s,e){let r=e||new f;return r=this.createRotateMatrix3D(t,s).multiply(this),r}scale2D(t,s,e){let r=e||new f;return r=this.createScaleMatrix2D(t,s).multiply(this),r}scale3D(t,s,e,r){let n=r||new f;return n=this.createScaleMatrix3D(t,s,e).multiply(this),n}createRotateMatrix3D(t,s){const e=this.identity();return s==I.AXIS2DX&&(e.set(1,1,a.cos(t)),e.set(1,2,-a.sin(t)),e.set(2,1,a.sin(t)),e.set(2,2,a.cos(t))),s==I.AXIS2DY&&(e.set(0,0,a.cos(t)),e.set(0,2,a.sin(t)),e.set(2,0,-a.sin(t)),e.set(2,2,a.cos(t))),s==I.AXIS2DZ&&(e.set(0,0,a.cos(t)),e.set(0,1,-a.sin(t)),e.set(1,0,a.sin(t)),e.set(1,1,a.cos(t))),e}createScaleMatrix2D(t,s){const e=this.identity();return e.set(0,0,t),e.set(1,1,s),e}createScaleMatrix3D(t,s,e){const r=this.identity();return r.set(0,0,t),r.set(1,1,s),r.set(2,2,e),r}}const K={2:C,3:D,4:f};class y{static create(t,s,e,r){return new U(t,s,e,r)}static createFromEuler(t,s,e){const r=y.create(0,-a.sin(s*.5),0,a.cos(s*.5)),n=y.create(-a.sin(t*.5),0,0,a.cos(t*.5)),i=y.create(0,0,-a.sin(e*.5),a.cos(e*.5)),o=y.multiply(r,n);return y.multiply(o,i)}static createFromAxisAndRadians(t,s){const e=g.normalize(t),r=s*.5,n=a.sin(r);return y.create(e.x*n,e.y*n,e.z*n,a.cos(r))}static identity(){return new U(0,0,0,1)}static add(t,s){const e=t.x+s.x,r=t.y+s.y,n=t.z+s.z,i=t.w+s.w;return y.create(e,r,n,i)}static sub(t,s){const e=t.x-s.x,r=t.y-s.y,n=t.z-s.z,i=t.w-s.w;return y.create(e,r,n,i)}static multiply(t,s){const e=t.w*s.w-t.x*s.x-t.y*s.y-t.z*s.z,r=t.w*s.x+t.x*s.w+t.y*s.z-t.z*s.y,n=t.w*s.y+t.y*s.w+t.z*s.x-t.x*s.z,i=t.w*s.z+t.z*s.w+t.x*s.y-t.y*s.x;return y.create(r,n,i,e)}static scale(t,s){const e=t.x*s,r=t.y*s,n=t.z*s,i=t.w*s;return y.create(e,r,n,i)}static dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w}static conjugate(t){return y.create(-t.x,-t.y,-t.z,t.w)}static normalize(t){const s=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z+t.w*t.w);if(s==0)throw new Error("Zero length quaternion. Cannot normalize!!");const e=1/s;return y.scale(t,e)}static inverse(t){const s=t.x*t.x+t.y*t.y+t.z*t.z+t.w*t.w;if(s==0)throw new Error("Zero length quaternion. Cannot inverse!!");const e=1/s,r=y.conjugate(t);return y.scale(r,e)}static rotateVector(t,s){const e=y.toQuaternion(s),r=y.inverse(t),n=y.multiply(t,e),i=y.multiply(n,r);return new E(i.x,i.y,i.z)}static slerp(t,s,e){let r=y.dot(t,s);r<0&&(s=y.scale(s,-1),r*=-1);const n=Math.acos(r),i=a.sin(n);if(i==0){const o=y.scale(t,1-e),c=y.scale(s,e);return y.add(o,c)}else{const o=y.scale(t,a.sin(n*(1-e))/i),c=y.scale(s,a.sin(n*e)/i);return y.add(o,c)}}static toQuaternion(t){return y.create(t.x,t.y,t.z,0)}}class U{constructor(t,s,e,r){S(this,"components");this.components=new Float32Array([t,s,e,r])}get x(){return this.components[0]}get y(){return this.components[1]}get z(){return this.components[2]}get w(){return this.components[3]}toMatrix(){const t=new f;let s=t.identity();const e=y.rotateVector(this,I.AXIS2DX),r=y.rotateVector(this,I.AXIS2DY),n=y.rotateVector(this,I.AXIS2DZ);return s.set(0,0,e.x),s.set(0,1,e.y),s.set(0,2,e.z),s.set(0,0,r.x),s.set(0,1,r.y),s.set(0,2,r.z),s.set(0,0,n.x),s.set(0,1,n.y),s.set(0,2,n.z),t}toEuler(){const t=this.toMatrix(),s=Math.atan2(t.get(0,2),t.get(2,2)),e=Math.asin(-t.get(2,0)),r=Math.atan2(t.get(2,1),t.get(2,2));return{pitch:s,yaw:e,roll:r}}}class ${static identity22(){return new C().identity()}static identity33(){return new D().identity()}static identity44(){return new f().identity()}static add(t,s){if(!this.checkSizeEqual(t,s))throw new Error("Not Equal Matrix Dimension. Cannot Calculate!");const e=this.createMatrixInstance(t.size);return t.add(s,e),e}static sub(t,s){if(!this.checkSizeEqual(t,s))throw new Error("Not Equal Matrix Dimension. Cannot Calculate!");const e=this.createMatrixInstance(t.size);return t.sub(s,e),e}static multiply(t,s){const e=this.createMatrixInstance(t.size);if(s instanceof R){if(t.col!=s.row)throw new Error("Not Equal A Row Number and B Col Number. Cannot Multiply!");t.multiply(s,e)}else t.multiply(s,e);return e}static div(t,s){if(s==0)throw new Error("b is zero. Cannot Divide!");const e=this.createMatrixInstance(t.size);return t.div(s,e),e}static translate2D(t,s){return t.translate2D(s)}static translate3D(t,s){return t.translate3D(s)}static rotate2D(t,s){return t.rotate2D(s)}static rotate3D(t,s,e){return t.rotate3D(s,e)}static scale2D(t,s,e){return t.scale2D(s,e)}static scale3D(t,s,e,r){return t.scale3D(s,e,r)}static transpose(t){return t.transpose()}static inverse(t){return t.inverse()}static orthographic(t,s,e,r,n,i){let o=new f;return o=o.orthographic(t,s,e,r,n,i,o),o}static perspective(t,s,e,r,n){let i=new f;return i=i.perspective(t,s,e,r,n,i),i}static lookAt(t,s,e){let r=new f;return r=r.lookAt(t,s,e,r),r}static checkSizeEqual(t,s){return t.col!=s.col||t.row!=s.row?(console.log(`col: ${t.col},${s.col}`),console.log(`row: ${t.row},${s.row}`),!1):!0}static createMatrixInstance(t){const s=K[t];if(!s)throw new Error("Unsupport matrix size");return new s}}class B{constructor(t){S(this,"gl");this.gl=this.initializeWebGL2RenderingContext(t)}getWebGL2RenderingContext(){return this.gl}clearColor(t){this.gl.clearColor(t.red,t.green,t.blue,t.alpha),this.gl.clearDepth(1),this.gl.clear(this.gl.COLOR_BUFFER_BIT)}initializeWebGL2RenderingContext(t){const s=t.getContext("webgl2");if(s==null)throw new Error("Not Support WebGL2!!");return s}}const Y=Object.freeze(Object.defineProperty({__proto__:null,default:`#version 300 es

in vec3 aPosition;
uniform mat4 mvpMatrix;

void main(void){
    gl_Position = mvpMatrix * vec4(aPosition, 1.0);
}`},Symbol.toStringTag,{value:"Module"})),W=Object.freeze(Object.defineProperty({__proto__:null,default:`#version 300 es
precision highp float;

out vec4 outputColor;

void main(void){
    outputColor = vec4(1.0, 0.0, 0.0, 1.0);
}`},Symbol.toStringTag,{value:"Module"}));class V{constructor(t,s,e){S(this,"gl");S(this,"program");S(this,"vertexShader");S(this,"fragmentShader");this.gl=t,this.program=this.createProgram(s,e)}getProgram(){return this.program}createProgram(t,s){const e=this.gl.createProgram();if(this.vertexShader=this.compileShader(t,"vert"),this.fragmentShader=this.compileShader(s,"frag"),this.gl.attachShader(e,this.vertexShader),this.gl.attachShader(e,this.fragmentShader),this.gl.linkProgram(e),this.gl.getProgramParameter(e,this.gl.LINK_STATUS))return this.gl.useProgram(e),console.log("Create program success!!"),e;throw alert(this.gl.getProgramInfoLog(e)),new Error("Cannot create program!!")}compileShader(t,s){let e=this.createShader(s);if(this.gl.shaderSource(e,t),this.gl.compileShader(e),!this.gl.getShaderParameter(e,this.gl.COMPILE_STATUS))throw console.log(this.gl.getShaderInfoLog(e)),new Error("Cannot compile shader!!");return e}createShader(t){switch(t){case"vert":return this.gl.createShader(this.gl.VERTEX_SHADER);case"frag":return this.gl.createShader(this.gl.FRAGMENT_SHADER);default:throw new Error("Unknown type shader!!")}}}class q{constructor(t){S(this,"gl");S(this,"commonProgramCache",new Map);S(this,"programKey",new Set);this.gl=t}async loadShaderFromPath(t,s){var o;const e=await this.loadShader(t),r=await this.loadShader(s);let n=(o=s.split("/").pop())==null?void 0:o.split(".").shift(),i=new V(this.gl,e,r);this.commonProgramCache.set(n,i),console.log("loadShaderFromPath done"),console.log(this.commonProgramCache)}async loadCommonShaders(){const t=Object.assign({"../src/webgl/shader/default.vert":Y}),s=Object.assign({"../src/webgl/shader/default.frag":W}),e=new Map,r=new Map;Object.entries(t).forEach(([n,i])=>{var h;const o=i.default,c=(h=n.split("/").pop())==null?void 0:h.split(".").shift();e.set(c,o),this.programKey.add(c)}),Object.entries(s).forEach(([n,i])=>{var h;const o=i.default,c=(h=n.split("/").pop())==null?void 0:h.split(".").shift();r.set(c,o),this.programKey.add(c)});for(const n of this.programKey){console.log(n);let i=e.get(n),o=r.get(n);if(!i||!o){console.warn(`Shader pair incomplete for key: ${n}`);continue}let c=new V(this.gl,i,o);this.commonProgramCache.set(n,c)}console.log("loadCommonShaders done"),console.log(this.commonProgramCache)}async loadShader(t){try{return await(await fetch(t)).text()}catch(s){throw console.error(s),new Error("Cannot load shader!!")}}}function J(){console.log("ライブラリが初期化されました")}u.Color=T,u.Color255=O,u.ColorUtility=H,u.DefaultColorConstants=Z,u.DefaultValueConstants=L,u.DefaultVectorConstants=I,u.MathUtility=a,u.Matrix=R,u.Matrix22=C,u.Matrix33=D,u.Matrix44=f,u.MatrixCalculator=$,u.MatrixClassAndSizePair=K,u.MyColorCode=G,u.MyColorConstants255=X,u.Quaternion=U,u.QuaternionCalculator=y,u.ShaderLoader=q,u.TrigonometricConstants=M,u.Vector=N,u.Vector2=F,u.Vector3=E,u.Vector4=P,u.VectorCalculator=g,u.VectorClassAndSizePair=j,u.WebGLUtility=B,u.initializeLibrary=J,Object.defineProperty(u,Symbol.toStringTag,{value:"Module"})});
